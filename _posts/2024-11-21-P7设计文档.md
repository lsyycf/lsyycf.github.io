---
layout: post
title: "北航计组P7设计文档"
date:   2024-11-21
tags: [计算机组成原理]
comments: true
author: lsyycf
---
Verilog实现五级全速转发流水线CPU，支持中断处理
<!-- more -->

# 一、模块设计

## 模块一：寄存器堆

- 功能同 P0 第三题 GRF

## 模块二：算术逻辑单元

- ALUOp 决定 ALU 进行的运算

## 模块三：取指令模块

- 每个时钟周期上升沿将pcNext赋值给pc
- 将pc的值减去初值0x00003000，作为ROM读取的地址addr
- pc若为0则将pc置为初始值0x00003000，地址置为0

## 模块四：乘除模块

- 进行乘除运算，结果存入内部相应的寄存器
- 通过busy信号对后续指令进行阻塞
- 写使能时，将值写入内部寄存器中
- 根据控制信号，输出内部寄存器地计算结果

##  模块五：控制信号生成器

### （1）D段

- **pcOp**：设置程序计数器的操作。
- **cmpOp**：表示条件跳转比较。
- **extOp**：是否需要扩展符号。
- **regWE**：表示寄存器写使能。
- **MD** ：是否需要使用乘除模块。
- **rtTuse** 和 **rsTuse**：再过几个周期，该指令要使用  rs 或  rt 寄存器的值。
- **eret**：是否是eret指令。
- **delay**：是否是延迟槽指令。
- **syscall**：是否是syscall指令。
- **RI**：不存在的指令。

### （2）E段

- **ALUOp**：决定 ALU 执行的操作。
- **MDOp**：决定 MD 执行的操作。
- **MDWE**：表示HI、LO寄存器写使能。
- **MDAddrOp**：选择读取 MD 中的寄存器。
- **resOp**：选择E段结果来自 ALU 还是 MD。
- **ALUIn2Op**：确定 ALU 第二个输入。
- **fwAddrOp**：选择转发的地址。
- **fwDataOp**：选择转发的数据。
- **Tnew**：表示以D级为基准，再过几个周期，该指令产生所需的结果。
- **mtc0**：是否是mtc0指令。
- **load**：是否是访存型指令。
- **store**：是否是存储型指令。
- **cal**：是否是计算型指令。

### （3）M段

- **memStoreOp**：决定写入主存的数据是字、字节和半字。
- **memLoadOp**：决定主存读出的数据是字、字节和半字。
- **fwAddrOp**：选择转发的地址。
- **fwDataOp**：选择转发的数据。
- **Tnew**：从结果产生到存入流水线寄存器需要几个周期。
- **eret**：是否是eret指令。
- **mtc0**：是否是mtc0指令.
- **mfc0**：是否是mfc0指令。

### （4）W段

- **fwAddrOp**：选择转发的地址。
- **fwDataOp**：选择转发的数据。
- **Tnew**：从结果产生到存入流水线寄存器需要几个周期。

## 模块六：流水线寄存器

- **D段**：存储 pc、指令、异常码、是否是延迟槽指令
- **E段**：存储 pc、指令、rs 和  rt 读出的数据、立即数、是否写入寄存器、异常码、是否是延迟槽指令
- **M段**：存储 pc、指令、rs 和  rt 读出的数据、立即数、ALU 计算结果、是否写入寄存器、异常码、是否是延迟槽指令
- **W段**：存储 pc、指令、rs 和  rt 读出的数据、立即数、ALU 计算结果、主存读出结果、是否写入寄存器

## 模块七：字节/半字/字选择模块

- 根据ALU计算地址的后两位，以及存取指令的类型，决定主存存取的数据

## 模块八：CP0模块

- 放置在M级流水段
- 一方面尽可能多的收集前段的异常，另一方面防止异常数据写回寄存器
- 通过异常码修改三个内部寄存器的值
- 支持内部寄存器的读写操作

## 模块九：桥

- 获取CPU申请访问的地址，读取相应的数据
- 通过地址的区间确定数据位于主存、Timer0、Timer1中

## 模块十：Timer

- 课程组已给出代码
- 两种模式给出模拟中断信号
- 通过地址读写Timer内存

# 二、阻塞与转发

## 1.阻塞

### 条件：
- 读写寄存器冲突
  - Tuse\<Tnew 
  - 需要将后续数据写入寄存器
  - 写入寄存器地址不为0
  - 写入寄存器地址与后续转发地址相同
- 乘除单元使用冲突
  - MD单元处于busy状态
  - 后续指令需要使用MD单元
- eret 指令冲突
  - D段是eret指令
  - E段或M段需要写CP0寄存器


### 行为：
- 停止取下一条指令
- D级寄存器保持原值不变
- E级寄存器复位（延迟槽指令除外）

## 2.转发

###  条件：
- Tnew=0
- 需要将后续数据写入寄存器
- 写入寄存器地址不为0
- 写入寄存器地址与后续转发地址相同

### 通路：
- E段->D段
- M段->D段、E段
- W段->D段、E段、M段

### 内容：
- 转发地址：写入的寄存器
- 转发数据：写入寄存器的内容

# 三、异常

| 中断码 | 助记符与名称 | 指令与指令类型 | 描述 | 收集 |
| ---- | ---- | ---- | ---- | --- |
| 0 | `Int`（外部中断） | 所有指令 | 中断请求，来源于计时器与外部中断。 | - |
| 4 | `AdEL`（取指异常） | 所有指令 | PC 地址未字对齐。<br>PC 地址超过 `0x3000 ~ 0x6ffc`。 | F段 |
| 4 | `AdEL`（取数异常） | `lw` | 取数地址未与 4 字节对齐。 | M段 |
| 4 | `AdEL`（取数异常） | `lh` | 取数地址未与 2 字节对齐。 | M段 |
| 4 | `AdEL`（取数异常） | `lh`，`lb` | 取 Timer 寄存器的值。 | M段 |
| 4 | `AdEL`（取数异常） | load 型指令 | 计算地址时加法溢出。 | E段 |
| 4 | `AdEL`（取数异常） | load 型指令 | 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 | M段 |
| 5 | `AdES`（存数异常） | `sw` | 存数地址未 4 字节对齐。 | M段 |
| 5 | `AdES`（存数异常） | `sh` | 存数地址未 2 字节对齐。 | M段 |
| 5 | `AdES`（存数异常） | `sh`，`sb` | 存 Timer 寄存器的值。 | M段 |
| 5 | `AdES`（存数异常） | store 型指令 | 计算地址加法溢出。 | E段 |
| 5 | `AdES`（存数异常） | store 型指令 | 向计时器的 Count 寄存器存值。 | M段 |
| 5 | `AdES`（存数异常） | store 型指令 | 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 | M段 |
| 8 | `Syscall`（系统调用） | `syscall` | 系统调用。 | D段 |
| 10 | `RI`（未知指令） | - | 未知的指令码。 | D段 |
| 12 | `Ov`（溢出异常） | `add`，`addi`，`sub` | 算术溢出。 | E段 |

# 四、思考题

## 问题一、
- Q：请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？
- A：鼠标和键盘的输入信号都会转化为不同的系统中断信号，CPU根据中断信号的值可以执行对应的汇编指令，这样就实现了相应鼠标和键盘的功能
## 问题二、
- Q：请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）
- A：必须是已经指定好的地址。处理中断异常程序的目的是维护系统、程序的正常运行，并返回错误信息。如果地址由用户自定义，可能地址无效产生新的异常，达不到目的


## 问题三、
- Q：为何与外设通信需要 Bridge？
- A：一方面，CPU不需要关心具体的数据从何而来，只需通过地址就能获得对应的数据，达到了高内聚低耦合的目的。另一方面，外设种类很多而CPU指令集有限，把外设的接口和CPU的接口通过系统桥连接起来，通过统一的方式，由系统桥选择相关信息的输入输出，使得CPU能够支持各种外设，有更强的拓展性和灵活性
## 问题四、
- Q：请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。

- 计数器模式 0
	- 当计数器倒计数为 0 后，计数器停止计数，寄存器的计数使能自动变为 0，中断信号始终保持有效，状态机在中断状态下循环，直到屏蔽中断或重新开始计数
	
- 计数器模式 1
	- 当计数器倒计时为 0 后， 初值寄存器值被自动加载至计数器，然后重新开始计数。在这种模式下，中断信号只会产生一个周期
- 状态转移图
	![mode](A:\IDE\Idea\mode.png)
## 问题五、
- Q：倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？
- CPU此时不知道应该要进行的操作是什么，在异常处理程序返回时EPC中返回的值为0，导致程序错乱
- 在清空流水线的时候，应该保留被阻塞的当前指令的PC值、判断其是否为延迟槽指令的BD位控制信号

## 问题六、
- Q：为什么 jalr 指令为什么不能写成 jalr \$31, \$31？
- A：因为 \$31 本身用来存储返回地址。如果你将返回地址存储到 \$31 中，并且又用它来确定跳转的目标地址，这样就会产生自引用，导致程序跳转到它自身的地址。进而程序会陷入死循环，或者跳转到错误的地址，破坏了正常的控制流

## P5&P6往年题及分类

1. **运算类指令**

 - R/I型指令（类似add/ori）
   - 1.将GPR[rs]中偶数位与GPR[rt]偶数位进行异或，奇数位保持不变结果存入GPR[rd]中
   - 2.将GPR[rs]中所有位的低GPR[rt]个0替换为1，若不够就全部替换，结果存放到GPR[rd]
   - 3.把GPR[rs]循环移位得到的32个结果无符号求和，把GPR[rt]循环移位得到的32个结果无符号求和，比较这两个结果，计算结果存入rd寄存器中
   - 4.如果GPR[rt]为奇数，则把GPR[rs]循环左移，左移位数是GPR[rt]的低五位，如果GPR[rt]为偶数，则把GPR[rs]循环右移，右移位数是GPR[rt]的低五位，结果存入rd寄存器中
   - 5.把立即数进行1扩展，然后与GPR[rs]相加，如果发生溢出，则向rt寄存器中写入1扩展的立即数，否则向rt寄存器中写入加法的结果
 - 乘除指令（类似mult）
   - 6.读取GPR[rs]和GPR[rt]，用较大的数除以较小的数（看作无符号数）
   - 7.交换HI、LO寄存器的值

2. **条件跳转类指令**

 - 跳转并链接（类似jal）
   - 8.如果GPR[rs]与GPR[rt]（看作有符号数）之中较小的数为偶数，则当前指令会以pc+4为基址，offset为偏移量进行跳转，否则清空延迟槽，无论是否跳转，都需要将pc+8存入31号号存器中
   - 9.比较pc加上偏移的结果与GPR[rs]+GPR[rt]的大小，如果前者小于后者，则以pc+4为基址，offset为偏移量进行跳转，否则跳转到GPR[rs]+GPR[rt]并清空延迟槽，无论何种跳转，都需要将pc+8存入31号号存器中
   - 10.如果GPR[rs]和GPR[rt]互为相反数，则以pc+4为基址，offset为偏移量进行跳转，否则不跳转，无论是否跳转，都需要将pc+8存入31号号存器中
   - 11.如果GPR[rs]的值小于0，则跳转到offset+2^k条指令后的位置，其中k为GPR[rt]的低两位，否则不跳转，无论是否跳转，都需要将pc+8存入31号号存器中
 - 只跳转不链接（类似beq）
   - 12.如果GPR[rs]的最高位与GPR[rt]的相同，则以pc+4为基址，offset为偏移量进行跳转，GPR[rs]等于0或GPR[rt]等于0时不跳转

3. **条件储存类指令**（类似lw）

 - 13.读取Memory[GPR[base]+offset]，假如该值小于0x80000000，将其写入特定寄存器中，否则写入rt寄存器，特定寄存器号为读取值的后四位，故而在GPR[0]~GPR[15]之间
 - 14.读取Memory[[GPR[base]+offset]，将0扩展的rt本身，存入特定寄存器，特定寄存器号为主存读取值的后四位
 - 15.读取Memory[[GPR[base]+offset]，写入特定寄存器中，特定寄存器号的计算方法是，将GPR[rt]和主存读出数据进行异或，得到的结果取低五位，特定寄存器号是小于或等于这个数的最大质数，如果没有这样的质数，特定寄存器号为0
 - 16.读取Memory[[GPR[base]+offset]的半字，判断这个半字中1的个数是否大于0的个数，如果1的个数多，就把这个半字到存入rt寄存器中 ，否则将pc+4存入31号号存器中
 - 17.读取Memory[[GPR[base]+offset]的字节，如果读出结果小于0，将结果写入base寄存器，否则写入rt寄存器中
 - 18.读取Memory[[GPR[base]+offset]，写入特定寄存器中，特定寄存器号的计算方法是，将主存读出数据与GRF[rt]相加后，计算结果与0x1e进行与运算
 - 19.读取Memory[[GPR[base]+offset]，如果读取数据大于GPR[rt]，则将其写入5号寄存器中，否则写入4号寄存器中
 - 20.读取Memory[[GPR[base]+offset]，如果读取数据大于等于0x00003000并且低两位都是0，就写入31号寄存器中，否则写入rt寄存器中

4. **特殊类指令**

 - 条件写入
   - 21.当GPR[rt]大于0时，将GPR[rs]写入rd寄存器中，否则不进行写入
   - 22.如果GPR[rt]等于0，则跳转到GPR[rs]所在的地址，并且将pc+8存入31号存器中，否则不进行写入
 - 复杂操作
   - 23.读取29号寄存器的值，作为地址将pc+8写入内存，而后29号寄存器的值减4，再写回29号寄存器，最后跳转到立即数对应的地址

## 解题套路

1. **运算类指令：修改E段结果的计算方法**

 - R/I型指令（类似add/ori）
   - 控制信号
     - 修改ALU的计算类型选择信号
     - 其余与add/ori相同
   - 顶层模块：
     - 在ALU中添加添加一种用于新指令的计算方法
 - 乘除指令（类似mult）
   - 控制信号
     - 修改乘除单元的计算类型选择信号
     - 修改busy的时钟周期数
     - 其余与mult相同
   - 顶层模块
     - 在乘除单元中添加一种用于新指令的计算方法
     - 根据运算时间需求，修改busy的时钟周期数

2. **条件跳转类指令：修改D段的比较方法，添加FD级寄存器的清空操作**

- 跳转并链接（类似jal）
  - 控制信号
    - 修改比较模块的比较方法选择信号
    - 修改跳转方法选择信号
    - 设置Tuse，D段需要立即用到rs和rt的读出结果进行判断，D段两个Tuse均设置为0
    - 设置Tnew，由于需要将D段的PC+8被写入寄存器，E、M、W段的Tnew设置为0
    - 改为有符号的立即数拓展
    - 其余与jal相同
  - 顶层模块
    - 在比较模块中添加添加一种用于新指令的计算方法
    - 新增一种用于新指令的跳转方法
    - 如果需要清空延迟槽，在满足该指令的清空条件，且不处于阻塞态时，复位FD级寄存器
- 只跳转不链接（类似beq）
  - 控制信号
    - 修改比较模块的比较方法选择信号
    - 修改跳转方法选择信号
    - 其余与beq相同
  - 顶层模块
    - 在比较模块中添加添加一种用于新指令的计算方法
    - 新增一种用于新指令的跳转方法

3. **条件储存类指令：预测可能写入的寄存器，基于此修改阻塞逻辑**
   - 控制信号
     - 修改W段写入寄存器地址的控制信号
     - 如果需要使用寄存器数据参与判断，将前段寄存器数据传到W段
     - 其余与lw相同
   - 顶层模块
     - 在W段新增一个用于确定新指令写入寄存器号的逻辑
     - 预测可能写入的寄存器号，构成一个集合，并去除0号寄存器
     - 增加阻塞逻辑：E或M级指令是新指令 且 需要写入寄存器 且 Tuse < Tnew 且 D段读取的寄存器在预测寄存器集合中
4. **特殊指令：具体问题具体分析**

- 条件写入
  - 特判寄存器的写使能信号：W级是新指令 且 满足条件
- 复杂操作
  - 特殊处理特殊部分的选择信号

## 公式做题就是快

1. **P5上机第二题**

 - 题干：比较pc加上偏移的结果与GPR[rs]+GPR[rt]的大小，如果前者小于后者，则以pc+4为基址，offset为偏移量进行跳转，否则跳转到GPR[rs]+GPR[rt]并清空延迟槽，无论何种跳转，都需要将pc+8存入31号号存器中

```verilog
// 1.D_CU.v 修改比较模块的比较方法选择信号
assign cmpOp = new ? `cmpOp_new;

// 2.D_CU.v 修改跳转方法选择信号
assign pcOp = new ? `pcOp_new;

// 3.D_CU.v 设置Tuse为0
assign rsTuse = new ? 2'b00;
assign rtTuse = new ? 2'b00;

// 4.E_CU.v M_CU.v W_CU.v 设置Tnew为0
assign Tnew = 2'b00;

// 5.mips.v 改为有符号的立即数拓展
assign extOp = new ? `signed_extend;

// 6.D_Cmp.v 在比较模块中添加添加一种用于新指令的计算方法
.cmpIn1 ((D_instr == new) ? D_pc + (D_extend_offset << 2) : D_rsData),
.cmpIn2 ((D_instr == new) ? D_rsData + D_rtData : D_rtData),
assign cmpRes = (cmpOp == `cmpOp_new) : (cmpIn1 < cmpIn2);

// 7.mips.v 新增一种用于新指令的跳转方法
assign F_nextPc = 
(pcOp == `pcOp_new) ? (D_cmpRes ? (D_pc + (D_extend_offset << 2) + 4) : (D_rsData + D_rtData));

// 8.mips.v 在满足该指令的清空条件，且不处于阻塞态时，复位FD级寄存器
.reset (reset || (D_instr == new && !D_cmpRes && !stall)),
```

2. **P5上机第三题**

- 题干：读取Memory[GPR[base]+offset]，假如该值小于0x80000000，将其写入特定寄存器中，否则写入rt寄存器，特定寄存器号为读取值的后四位，故而在GPR[0]~GPR[15]之间

```verilog
// 1.W_CU.v 修改W段写入寄存器地址的控制信号
assign writeDataOp = new ? `writeDataOp_new;

// 2.mips.v 在W段新增一个用于确定新指令写入寄存器号的逻辑
assign W_writeAddr = `writeDataOp_new ? (W_memRead < 32'h80000000 ? {1'b0, W_memRead[3:0]} : W_rt);

// 3.预测可能写入的寄存器号，构成一个集合，并去除0号寄存器
// 本题可以写入的寄存器集合是 1-15 号寄存器

// 4.mips.v 增加阻塞逻辑：E或M级指令是新指令 且 需要写入寄存器 且 Tuse < Tnew 且 D段读取的寄存器在预测寄存器集合中
assign stall =   
  (E_instr == new ? (D_rs > 0 && D_rs < 16 : D_rs == E_writeAddr) && D_rsTuse < E_Tnew && D_rs && E_regWE)
||(M_instr == new ? (D_rs > 0 && D_rs < 16 : D_rs == M_writeAddr) && D_rsTuse < M_Tnew && D_rs && M_regWE)
||(E_instr == new ? (D_rt > 0 && D_rt < 16 : D_rt == E_writeAddr) && D_rtTuse < E_Tnew && D_rt && E_regWE)
||(M_instr == new ? (D_rt > 0 && D_rt < 16 : D_rt == M_writeAddr) && D_rtTuse < M_Tnew && D_rt && M_regWE);
```
